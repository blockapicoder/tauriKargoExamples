<!doctype html>
<html lang="fr">

<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>Points 2D + Représentation 3D</title>
    <style>
        :root {
            --border: #444;
        }

        * {
            box-sizing: border-box;
        }

        body {
            margin: 0;
            font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Arial;
        }

        header {
            padding: 10px 14px;
            border-bottom: 1px solid var(--border);
            display: flex;
            gap: 12px;
            align-items: center;
            flex-wrap: wrap;
        }

        .hint {
            font-size: 13px;
            opacity: .75;
        }

        .container {
            display: flex;
            gap: 12px;
            padding: 12px;
            height: calc(100vh - 64px);
        }

        .panel {
            border: 1px solid var(--border);
            border-radius: 10px;
            padding: 10px;
            display: flex;
            flex-direction: column;
            min-width: 320px;
        }

        .panel h2 {
            margin: 0 0 8px 0;
            font-size: 14px;
            opacity: .75;
        }

        .fill {
            flex: 1 1 auto;
            position: relative;
        }

        canvas {
            width: 100%;
            height: 100%;
            display: block;
            border-radius: 8px;
            background: #fff;
        }

        .legend {
            font-size: 12px;
            opacity: .7;
            margin-top: 6px;
        }
    </style>
      <script type="importmap">
    {
        "imports": {
            "three": "./node_modules/three/build/three.module.js",
              "three/examples/jsm/": "/node_modules/three/examples/jsm/"
        }
    }

    </script>
</head>

<body>
    <header>
        <strong>Canvas points + hauteurs</strong>
        <span class="hint">Clic vide: ajouter · Clic sur un point: sélectionner · + / - : hauteur · Suppr/Retour:
            supprimer · Double-clic: supprimer · Glisser: déplacer</span>
    </header>

    <div class="container">
        <!-- Gauche : représentation 3D -->
        <section class="panel" style="flex: 1 1 50%;">
            <h2>Représentation 3D (isométrique)</h2>
            <div id="app">

            </div>
            <div class="legend">Colonnes isométriques projetées depuis la scène 2D (hauteur = h, position = (x,y)).
            </div>
        </section>

        <!-- Droite : canvas 2D interactif -->
        <section class="panel" style="flex: 1 1 50%;">
            <h2>Éditeur 2D</h2>
            <div class="fill">
                <canvas id="stage" aria-label="Plan de points"></canvas>
            </div>
        </section>
    </div>

    <script type="module">
        // --- Références ---
        const stage = document.getElementById('stage');
        const view3d = document.getElementById('view3d');
        const ctx2d = stage.getContext('2d');
        const ctx3d = view3d.getContext('2d');

        // --- DPR / Resize ---
        function fitCanvasToParent(canvas, ctx) {
            const dpr = window.devicePixelRatio || 1;
            const { width: cssW, height: cssH } = canvas.parentElement.getBoundingClientRect();
            canvas.width = Math.max(1, Math.round(cssW * dpr));
            canvas.height = Math.max(1, Math.round(cssH * dpr));
            // unité = px CSS
            ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
        }
        function resizeAll() {
            fitCanvasToParent(stage, ctx2d);
            fitCanvasToParent(view3d, ctx3d);
            draw2D();
            draw3D();
        }
        window.addEventListener('resize', resizeAll);

        // --- État ---
        /** @typedef {{ id:number, x:number, y:number, h:number }} P */
        /** @type {P[]} */
        let points = [];
        let selectedId = null;
        let draggingId = null;
        let dragOffset = { x: 0, y: 0 };

        const R = 8;      // rayon visuel du point 2D
        const HIT = 12;   // rayon de hit-test 2D
        const STEP = 1;   // pas d'ajustement de hauteur

        // --- Utilitaires ---
        const dist2 = (x1, y1, x2, y2) => (x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2);
        const nextId = (() => { let n = 1; return () => n++; })();

        function getPos(canvas, evt) {
            const rect = canvas.getBoundingClientRect();
            return { x: evt.clientX - rect.left, y: evt.clientY - rect.top };
        }
        function hitTest2D(x, y) {
            let nearest = null;
            let bestD2 = Infinity;
            for (const p of points) {
                const d2 = dist2(x, y, p.x, p.y);
                if (d2 <= HIT * HIT && d2 < bestD2) { bestD2 = d2; nearest = p; }
            }
            return nearest;
        }

        // --- Dessin 2D ---
        function drawGrid2D() {
            const w = stage.clientWidth, h = stage.clientHeight;
            ctx2d.save();
            ctx2d.clearRect(0, 0, w, h);
            ctx2d.lineWidth = 1;
            ctx2d.strokeStyle = '#e5e5e5';
            for (let x = 50; x < w; x += 50) { ctx2d.beginPath(); ctx2d.moveTo(x, 0); ctx2d.lineTo(x, h); ctx2d.stroke(); }
            for (let y = 50; y < h; y += 50) { ctx2d.beginPath(); ctx2d.moveTo(0, y); ctx2d.lineTo(w, y); ctx2d.stroke(); }
            ctx2d.restore();
        }
        function drawPoint2D(p, selected) {
            // disque
            ctx2d.beginPath();
            ctx2d.arc(p.x, p.y, R, 0, Math.PI * 2);
            ctx2d.fillStyle = selected ? '#222' : '#000';
            ctx2d.fill();

            // contour
            ctx2d.lineWidth = selected ? 3 : 1.5;
            ctx2d.strokeStyle = selected ? '#1e90ff' : '#444';
            ctx2d.stroke();

            // label hauteur
            const label = `h=${p.h}`;
            ctx2d.font = '13px system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Arial';
            const tw = ctx2d.measureText(label).width;
            const tx = Math.round(p.x - tw / 2);
            const ty = Math.round(p.y - R - 12);

            // tige
            ctx2d.beginPath();
            ctx2d.moveTo(p.x, p.y - R);
            ctx2d.lineTo(p.x, ty + 15);
            ctx2d.lineWidth = 1;
            ctx2d.strokeStyle = '#666';
            ctx2d.stroke();

            // cartouche
            ctx2d.fillStyle = 'rgba(255,255,255,0.95)';
            ctx2d.fillRect(tx - 4, ty - 2, tw + 8, 20);
            ctx2d.strokeStyle = '#888';
            ctx2d.strokeRect(tx - 4, ty - 2, tw + 8, 20);

            ctx2d.fillStyle = '#000';
            ctx2d.fillText(label, tx, ty + 13);
        }
        function draw2D() {
            const w = stage.clientWidth, h = stage.clientHeight;
            ctx2d.clearRect(0, 0, w, h);
            drawGrid2D();
            for (const p of points) drawPoint2D(p, p.id === selectedId);
        }

        // --- Dessin 3D (isométrique simplifiée) ---
        // Projection isométrique: (gx,gy,h) -> (sx,sy)
        // Paramètres de scène 3D
        const GROUND_SIZE = 400;        // taille "monde" pour gx/gy
        const HEIGHT_SCALE = 10;        // échelle d'extrusion pour h
        const ISO_SX = 0.6;             // facteur isométrique X
        const ISO_SY = 0.35;            // facteur isométrique Y
        const COL_R = 8;                // taille demi-largeur du top "diamant"

        function worldFrom2D(p) {
            // mappe x,y (en px 2D) vers gx,gy dans [0,GROUND_SIZE]
            const gx = (p.x / Math.max(1, stage.clientWidth)) * GROUND_SIZE;
            const gy = (p.y / Math.max(1, stage.clientHeight)) * GROUND_SIZE;
            const hz = p.h * HEIGHT_SCALE;
            return { gx, gy, hz };
        }

        function isoProject(gx, gy, hz, centerX, baseY) {
            // isométrique: écranX = cx + (gx - gy)*ISO_SX
            //              écranY = by + (gx + gy)*ISO_SY - hz
            const sx = centerX + (gx - gy) * ISO_SX;
            const sy = baseY + (gx + gy) * ISO_SY - hz;
            return { sx, sy };
        }

        function drawGround3D() {
            const w = view3d.clientWidth, h = view3d.clientHeight;
            ctx3d.clearRect(0, 0, w, h);

            // quadrillage isométrique (optionnel léger)
            ctx3d.lineWidth = 1;
            ctx3d.strokeStyle = '#e9e9e9';

            const cx = Math.round(w * 0.5);
            const by = Math.round(h * 0.6);
            // tracer quelques lignes de grille
            const step = 50;
            for (let t = 0; t <= GROUND_SIZE; t += step) {
                // lignes gx=t
                let a = isoProject(t, 0, 0, cx, by);
                let b = isoProject(t, GROUND_SIZE, 0, cx, by);
                ctx3d.beginPath(); ctx3d.moveTo(a.sx, a.sy); ctx3d.lineTo(b.sx, b.sy); ctx3d.stroke();

                // lignes gy=t
                a = isoProject(0, t, 0, cx, by);
                b = isoProject(GROUND_SIZE, t, 0, cx, by);
                ctx3d.beginPath(); ctx3d.moveTo(a.sx, a.sy); ctx3d.lineTo(b.sx, b.sy); ctx3d.stroke();
            }

            // contour "plateau"
            const A = isoProject(0, 0, 0, cx, by);
            const B = isoProject(GROUND_SIZE, 0, 0, cx, by);
            const C = isoProject(GROUND_SIZE, GROUND_SIZE, 0, cx, by);
            const D = isoProject(0, GROUND_SIZE, 0, cx, by);
            ctx3d.beginPath();
            ctx3d.moveTo(A.sx, A.sy); ctx3d.lineTo(B.sx, B.sy); ctx3d.lineTo(C.sx, C.sy); ctx3d.lineTo(D.sx, D.sy); ctx3d.closePath();
            ctx3d.strokeStyle = '#bbb';
            ctx3d.stroke();
        }

        function drawColumn3D(p) {
            const w = view3d.clientWidth, h = view3d.clientHeight;
            const cx = Math.round(w * 0.5);
            const by = Math.round(h * 0.6);

            const { gx, gy, hz } = worldFrom2D(p);
            const base = isoProject(gx, gy, 0, cx, by);
            const top = isoProject(gx, gy, hz, cx, by);

            // top "diamant"
            const tA = { x: top.sx, y: top.sy - COL_R };
            const tB = { x: top.sx + COL_R, y: top.sy };
            const tC = { x: top.sx, y: top.sy + COL_R };
            const tD = { x: top.sx - COL_R, y: top.sy };

            // couleur selon sélection
            const isSel = p.id === selectedId;
            const fillTop = isSel ? '#1e90ff' : '#6b7280';   // gris/bleu
            const fillSide1 = isSel ? '#7fb7ff' : '#9aa0a6';
            const fillSide2 = isSel ? '#5aa1ff' : '#8a9096';
            const strokeCol = '#3b3f46';

            // côté 1 (droite): top(B->C) vers base
            const bB = isoProject(gx + COL_R / ISO_SX, gy, 0, cx, by);
            const bC = isoProject(gx, gy + COL_R / ISO_SX, 0, cx, by);

            ctx3d.beginPath();
            ctx3d.moveTo(tB.x, tB.y); ctx3d.lineTo(tC.x, tC.y); ctx3d.lineTo(bC.sx, bC.sy); ctx3d.lineTo(bB.sx, bB.sy); ctx3d.closePath();
            ctx3d.fillStyle = fillSide1; ctx3d.fill();
            ctx3d.strokeStyle = strokeCol; ctx3d.stroke();

            // côté 2 (gauche): top(C->D) vers base
            const bD = isoProject(gx - COL_R / ISO_SX, gy, 0, cx, by);
            ctx3d.beginPath();
            ctx3d.moveTo(tC.x, tC.y); ctx3d.lineTo(tD.x, tD.y); ctx3d.lineTo(bD.sx, bD.sy); ctx3d.lineTo(bC.sx, bC.sy); ctx3d.closePath();
            ctx3d.fillStyle = fillSide2; ctx3d.fill();
            ctx3d.strokeStyle = strokeCol; ctx3d.stroke();

            // top
            ctx3d.beginPath();
            ctx3d.moveTo(tA.x, tA.y); ctx3d.lineTo(tB.x, tB.y); ctx3d.lineTo(tC.x, tC.y); ctx3d.lineTo(tD.x, tD.y); ctx3d.closePath();
            ctx3d.fillStyle = fillTop; ctx3d.fill();
            ctx3d.strokeStyle = strokeCol; ctx3d.stroke();

            // tige vers la base (optionnel)
            ctx3d.beginPath();
            ctx3d.moveTo(top.sx, top.sy);
            ctx3d.lineTo(base.sx, base.sy);
            ctx3d.strokeStyle = '#b0b0b0'; ctx3d.lineWidth = 1; ctx3d.stroke();
        }

        function draw3D() {
            drawGround3D();
            // simple ordre de peinture: colonnes du fond vers l'avant (gx+gy)
            const sorted = [...points].sort((a, b) => {
                const wa = worldFrom2D(a); const wb = worldFrom2D(b);
                return (wa.gx + wa.gy) - (wb.gx + wb.gy);
            });
            for (const p of sorted) drawColumn3D(p);
        }

        // --- Interactions 2D ---
        stage.addEventListener('mousedown', (e) => {
            const { x, y } = getPos(stage, e);
            const target = hitTest2D(x, y);
            if (target) {
                selectedId = target.id;
                draggingId = target.id;
                dragOffset.x = x - target.x;
                dragOffset.y = y - target.y;
                draw2D(); draw3D();
            } else {
                const p = { id: nextId(), x, y, h: 0 };
                points.push(p);
                selectedId = p.id;
                draw2D(); draw3D();
            }
        });
        stage.addEventListener('mousemove', (e) => {
            if (draggingId != null) {
                const p = points.find(pt => pt.id === draggingId);
                if (!p) return;
                const { x, y } = getPos(stage, e);
                p.x = Math.round(x - dragOffset.x);
                p.y = Math.round(y - dragOffset.y);
                draw2D(); draw3D();
            }
        });
        window.addEventListener('mouseup', () => { draggingId = null; });

        stage.addEventListener('dblclick', (e) => {
            const { x, y } = getPos(stage, e);
            const target = hitTest2D(x, y);
            if (target) {
                points = points.filter(p => p.id !== target.id);
                if (selectedId === target.id) selectedId = null;
                draw2D(); draw3D();
            }
        });

        window.addEventListener('keydown', (e) => {
            if (selectedId == null) return;
            const p = points.find(pt => pt.id === selectedId);
            if (!p) return;

            if (e.key === '+' || e.key === '=') {
                p.h += STEP; draw2D(); draw3D();
            } else if (e.key === '-' || e.key === '_') {
                p.h -= STEP; draw2D(); draw3D();
            } else if (e.key === 'Delete' || e.key === 'Backspace') {
                points = points.filter(pt => pt.id !== selectedId);
                selectedId = null; draw2D(); draw3D();
            }
        });

        // --- Init ---
        resizeAll();
        // Quelques points de démo
        points.push({ id: nextId(), x: 0.25 * stage.clientWidth, y: 0.3 * stage.clientHeight, h: 3 });
        points.push({ id: nextId(), x: 0.55 * stage.clientWidth, y: 0.55 * stage.clientHeight, h: 6 });
        points.push({ id: nextId(), x: 0.80 * stage.clientWidth, y: 0.35 * stage.clientHeight, h: -2 });
        draw2D(); draw3D();
    </script>
</body>
<script type="module" src="./index2.ts"></script>

</html>